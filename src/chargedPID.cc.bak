#include <BushConnect.hh>
#include <ArborTool.hh>
#include <ArborToolLCIO.hh>
#include <EVENT/LCCollection.h>
#include <EVENT/MCParticle.h>
#include <EVENT/CalorimeterHit.h>
#include <EVENT/SimCalorimeterHit.h>
#include <EVENT/LCFloatVec.h>
#include <EVENT/LCParameters.h>
#include <EVENT/Cluster.h>
#include <EVENT/LCRelation.h>

#include <IMPL/ReconstructedParticleImpl.h>
#include <IMPL/LCCollectionVec.h>
#include <IMPL/LCFlagImpl.h>
#include <IMPL/LCRelationImpl.h>
#include <IMPL/ClusterImpl.h>
#include "UTIL/CellIDDecoder.h"
#include "DetectorPos.hh"
#include "HelixClass.hh"

#include <string>
#include <iostream>
#include <cmath>
#include <vector>
#include <stdexcept>
#include <TMath.h>
#include <TFile.h>
#include <TTree.h>
#include <Rtypes.h>
#include <sstream>
#include <TH1.h>
#include <TVector3.h>

#include "TMVA/Tools.h"
#include "TMVA/Reader.h"
#include "TMVA/Config.h"



using namespace std;

const float TightGeoThreshold = 30;

const string ECALCellIDDecoder  = "M:3,S-1:3,I:9,J:9,K-1:6";

BushConnect aBushConnect ;
BushConnect::BushConnect()
	: Processor("BushConnect"),
	_output(0)
{
	_description = "Track Cluster Linking. Track info represented by MCTruth at this moment" ;
	registerProcessorParameter( "TreeOutputFile" ,
			                        "The name of the file to which the ROOT tree will be written" ,
						                        _treeFileName ,
									                        _treeFileName);
	registerProcessorParameter( "outputroot",
			"whether root file or not",
			_outputtestroot,
			_outputtestroot);
}

void BushConnect::init() {

	printParameters();

	Cluflag.setBit(LCIO::CHBIT_LONG);
	//if(!_outputtestroot)continue;
	tree_file=new TFile(_treeFileName.c_str(), "RECREATE");
	arborTree = new TTree("Arbor","Arbor");

	arborTree->Branch("EventNr", &eventNr, "EventNr/I");
	arborTree->Branch("EcalNHit",&EcalNHit,"EcalNHit/I");
	arborTree->Branch("HcalNHit",&HcalNHit,"HcalNHit/I");
	arborTree->Branch("CluNHit",&CluNHit,"CluNHit/I");
	arborTree->Branch("NLEcal",&NLEcal,"NLEcal/I");
	arborTree->Branch("NLHcal",&NLHcal,"NLHcal/I");
	arborTree->Branch("maxDisHtoL",&maxDisHtoL,"maxDisHtoL/F");
	arborTree->Branch("minDisHtoL",&minDisHtoL,"minDisHtoL/F");
	arborTree->Branch("avDisHtoL",&avDisHtoL,"avDisHtoL/F");
	arborTree->Branch("avEnDisHtoL",&avEnDisHtoL,"avEnDisHtoL/F");
	arborTree->Branch("EcalEn",&EcalEn,"EcalEn/F");
	arborTree->Branch("HcalEn",&HcalEn,"HcalEn/F");
	arborTree->Branch("EClu",&EClu,"EClu/F");
	arborTree->Branch("graDepth",&graDepth,"graDepth/F");
	arborTree->Branch("cluDepth",&cluDepth,"cluDepth/F");
	arborTree->Branch("graAbsDepth",&graAbsDepth,"graAbsDepth/F");
	arborTree->Branch("maxDepth",&maxDepth,"maxDepth/F");
	arborTree->Branch("minDepth",&minDepth,"minDepth/F");
	arborTree->Branch("MaxDisHel",&MaxDisHel,"MaxDisHel/F");
	arborTree->Branch("MinDisHel",&MinDisHel,"MinDisHel/F");
	arborTree->Branch("FD_all",&FD_all,"FD_all/F");
	arborTree->Branch("FD_ECAL",&FD_ECAL,"FD_ECAL/F");
	arborTree->Branch("FD_HCAL",&FD_HCAL,"FD_HCAL/F");
	arborTree->Branch("crdis",&crdis,"crdis/F");
	arborTree->Branch("EEClu_L10",&EEClu_L10,"EEClu_L10/F");
	arborTree->Branch("EEClu_R",&EEClu_R,"EEClu_R/F");
	arborTree->Branch("EEClu_r",&EEClu_r,"EEClu_r/F");
	arborTree->Branch("EEClu_p",&EEClu_p,"EEClu_p/F");
	arborTree->Branch("rms_Ecal",&rms_Ecal,"rms_Ecal/F");
	arborTree->Branch("rms_Hcal",&rms_Hcal,"rms_Hcal/F");
	arborTree->Branch("rms_Ecal2",&rms_Ecal2,"rms_Ecal2/F");
	arborTree->Branch("rms_Hcal2",&rms_Hcal2,"rms_Hcal2/F");
	arborTree->Branch("av_NHE",&av_NHE,"av_NHE/F");
	arborTree->Branch("av_NHH",&av_NHH,"av_NHH/F");
	arborTree->Branch("AL_Ecal",&AL_Ecal,"AL_Ecal/I");
	arborTree->Branch("AL_Hcal",&AL_Hcal,"AL_Hcal/I");
	arborTree->Branch("FD_ECALF10",&FD_ECALF10,"FD_ECALF10/F");
	arborTree->Branch("FD_ECALL20",&FD_ECALL20,"FD_ECALL20/F");
	arborTree->Branch("NH_ECALF10",&NH_ECALF10,"NH_ECALF10/I");
	arborTree->Branch("NH_ECALL20",&NH_ECALL20,"NH_ECALL20/I");
	arborTree->Branch("dEdx",&dEdx,"dEdx/F");
	arborTree->Branch("mvaVal_pi",&mvaVal_pi,"mvaVal_pi/F");
	arborTree->Branch("mvaVal_mu",&mvaVal_mu,"mvaVal_mu/F");
	arborTree->Branch("mvaVal_e",&mvaVal_e,"mvaVal_e/F");
	arborTree->Branch("cosTheta",&cosTheta,"cosTheta/F");
	arborTree->Branch("Phi",&Phi,"Phi/F");
	reader_all.clear();
	
	int level[]={1,2,3,5,7,10,20,30,40,50,70};
	for(int i=0;i<11;i++){
		TMVA::Reader *reader;
      		TString wgtFname;
	
   		TString dir = "/scratchfs/higgs/yudan/PID/";
   		TString slevel = Form("%d",level[i]);
   		wgtFname = dir + "TMVA_"+ slevel +"GeV/weights/TMVAMulticlass_BDTG.weights.xml";

		TMVA::Tools::Instance();
   		reader = new TMVA::Reader( "!Color:Silent" );
		float _EcalNHit=(float)EcalNHit;
		float _HcalNHit=(float)HcalNHit;
		float _NLEcal=(float)NLEcal;
		float _NLHcal=(float)NLHcal;
		float _av_NHH=(float)av_NHH;
		float _AL_Ecal=(float)AL_Ecal;
		float _NH_ECALF10=(float)NH_ECALF10;
		float EE, E_10, E_R, E_r;
		reader->AddVariable("EcalNHit", &_EcalNHit);
		reader->AddVariable("HcalNHit", &_HcalNHit);
		reader->AddVariable("NLEcal", &_NLEcal);
		reader->AddVariable("NLHcal", &_NLHcal);
		reader->AddVariable("maxDisHtoL",&maxDisHtoL);
		reader->AddVariable("avDisHtoL",&avDisHtoL);
		reader->AddVariable("EE := EcalEn/EClu",&EE);
		reader->AddVariable("graDepth",&graDepth);
		reader->AddVariable("cluDepth",&cluDepth);
		reader->AddVariable("minDepth",&minDepth);
		reader->AddVariable("MaxDisHel",&MaxDisHel);
		reader->AddVariable("FD_all",&FD_all);
		reader->AddVariable("FD_ECAL",&FD_ECAL);
		reader->AddVariable("FD_HCAL",&FD_HCAL);
		reader->AddVariable("E_10 := EEClu_L10/EcalEn",&E_10);
		reader->AddVariable("E_R := EEClu_R/EcalEn",&E_R);
		reader->AddVariable("E_r := EEClu_r/EcalEn",&E_r);
		reader->AddVariable("rms_Hcal",&rms_Hcal);
		reader->AddVariable("rms_Hcal2",&rms_Hcal2);
		reader->AddVariable("av_NHH", &_av_NHH);
		reader->AddVariable("AL_Ecal", &_AL_Ecal);
		reader->AddVariable("FD_ECALF10",&FD_ECALF10);
		reader->AddVariable("FD_ECALL20",&FD_ECALL20);
		reader->AddVariable("NH_ECALF10", &_NH_ECALF10);
		reader->AddVariable("dEdx",&dEdx);
	
		E_R=EEClu_R/EcalEn;
		E_r=EEClu_r/EcalEn;
		E_10=EEClu_L10/EcalEn;
		EE=EcalEn/EClu;
   		reader->BookMVA("BDTG", wgtFname);
		reader_all.push_back(reader);


	}	
}

void BushConnect::Clean(){

	Track_Energy.clear();
	Track_Type.clear();
	SortedTracks.clear();
	SortedSMBushes.clear();
	SMBushes_Type.clear();

	ClusterType_1stID.clear();
	ChCoreID.clear();

	ecalchcore_tight.clear();
	ecalchcore_medium.clear();
	ecalchcore_loose.clear();
	ecalchcore.clear();
	ecalnecore_EM.clear();
	ecalnecore_NonEM.clear();
	ecalfrag.clear();
	ecalundef.clear();
	ecalfrag_TBM_CH.clear();
	ecalfrag_TBM_NE_EM.clear();
	ecalfrag_TBM_NE_NonEM.clear();
	ecalpotentialbackscattering.clear();
	ecalundef_iso.clear();

	hcalchcore_tight.clear();
	hcalchcore_medium.clear();
	hcalchcore_loose.clear();
	hcalnecore.clear();
	hcalchcore.clear();
	hcalfrag.clear();
	hcalfrag_TBM_CH.clear();
	hcalfrag_TBM_NE_EM.clear();
	hcalfrag_TBM_NE_NonEM.clear();
	hcalundef.clear();
	hcalundef_iso.clear();

	trkendposition.clear();
	CluFD.clear();
	chargedclustercore.clear();
	non_chargedclustercore.clear();		//all clusters besides charged cluster core
}

void BushConnect::NewClusterFlag(Cluster* a_tree, Track* a_trk, LCCollection *col_TPCTrk)
{
	// give each charged core cluster a flag
	//  Fragmentation:       999
	//  MIP: matched         130
	//       non-matched     131
	//  EM:  matched         110
	//       non-matched     111
	//  HAD: matched         211
	//       non-matched     212

	int NH[16], NL[16];
	float FD[16]; 
	CluIDFlag=999; 
	
	ClusterID = 211;
	dEdx=0;

	const string ECALCellIDDecoder = "M:3,S-1:3,I:9,J:9,K-1:6";
	CellIDDecoder<CalorimeterHit> idDecoder(ECALCellIDDecoder);
	const float mass = 0.139;       //Pion Mass

	HelixClass * TrkInit_Helix = new HelixClass();
	TrkInit_Helix->Initialize_Canonical(a_trk->getPhi(), a_trk -> getD0(), a_trk -> getZ0(), a_trk -> getOmega(), a_trk->getTanLambda(), BField);
	float TrackEn = mass*mass;

	int ntpctrk = col_TPCTrk->getNumberOfElements();

	for (int q3 = 0; q3 < 3; q3 ++)
	{
		TrackEn += (TrkInit_Helix->getMomentum()[q3])*(TrkInit_Helix->getMomentum()[q3]);
	}
	delete TrkInit_Helix;

	TrackEn = sqrt(TrackEn);
	int nSubTrk = a_trk->getTracks().size();

	int NHit = a_tree->getCalorimeterHits().size();
	if ( (NHit > 4 && TrackEn > 1) || TrackEn <= 1 )
	{

		for(int t0 = 0; t0 < ntpctrk; t0++)
		{
			Track *a_tpctrk = dynamic_cast<EVENT::Track *>(col_TPCTrk->getElementAt(t0));
			float TPCD0 = a_tpctrk->getD0();
			float TPCZ0 = a_tpctrk->getZ0();
			float TPCPhi = a_tpctrk->getPhi();
			float TPCTL = a_tpctrk->getTanLambda();
			for(int t1 = 0; t1 < nSubTrk; t1++)
			{
				Track* a_SubTrk = a_trk->getTracks()[t1];
				float SubD0 = a_SubTrk->getD0();
				float SubZ0 = a_SubTrk->getZ0();
				float SubPhi = a_SubTrk->getPhi();
				float SubTL = a_SubTrk->getTanLambda();
				if (fabs(SubTL-TPCTL) < 1.0E-6 && fabs(SubD0-TPCD0) < 1.0E-6 && fabs(SubZ0-TPCZ0) < 1.0E-6 && fabs(SubPhi-TPCPhi) < 1.0E-6)
				{
					std::vector<TrackerHit*> trhits = a_tpctrk->getTrackerHits();
                                   	int nhit = trhits.size();
                                        int chose_high = int(0.3*nhit);
                                        float cen_high = 999.;
                                        int maxhit = 99999;
                                        float totaled = 0.;

                                        for(int ihit = 0; ihit < chose_high;ihit++){

                                        	maxhit = ihit;
                                                TrackerHit * hiti = dynamic_cast<TrackerHit*>(trhits[maxhit]);
                                                TrackerHit * hiti1 = dynamic_cast<TrackerHit*>(trhits[maxhit+1]);
                                                TVector3 hitposi = hiti->getPosition();
                                                TVector3 lastposi = hiti1->getPosition();
                                                float cudisi = (hitposi-lastposi).Mag();
                                                float maxdedx = hiti->getEDep()/cudisi;
                                                for(int jhit = ihit+1; jhit<nhit-1; jhit++){

                                                	TrackerHit * hitj = dynamic_cast<TrackerHit*>(trhits[jhit]);

                                                        TrackerHit * hitj1 = dynamic_cast<TrackerHit*>(trhits[jhit+1]);
                                                        TVector3 hitposj = hitj->getPosition();
                                                        TVector3 lastposj = hitj1->getPosition();
                                                        float cudisj = (hitposj-lastposj).Mag();
                                                        if(hitj->getEDep()/cudisj>maxdedx&&hitj->getEDep()/cudisj<cen_high){
                                                        	maxhit = jhit;
                                                        	maxdedx = hitj->getEDep()/cudisj;
                                                        }
                                                }
                                                cen_high = maxdedx;
                                       	}
                                       	int nhiteff = 0;


                                        for(int ihit = 0; ihit < nhit-1; ihit++)
                                        {
                                             	TrackerHit * hit = dynamic_cast<TrackerHit*>(trhits[ihit]);

                                                float mindis = 999.;
                                                TrackerHit * last = dynamic_cast<TrackerHit*>(trhits[ihit+1]);
                                                TVector3 hitpos = hit->getPosition();
                                                TVector3 lastpos = last->getPosition();
                                                float cudis = (hitpos-lastpos).Mag();
                                                mindis= cudis;
                                               	if(hit->getEDep()/mindis<cen_high){
                                                	float dedx = hit->getEDep()/mindis;
                                                	totaled += dedx;
                                                	nhiteff ++;
                                        	}
                                        }
                                        dEdx = totaled/nhiteff;
				}
			}
					
		}

		TVector3 CluPos;
		CluPos = a_tree->getPosition();
		cosTheta=CluPos[2]/CluPos.Mag();
		Phi=atan2(CluPos[1],CluPos[0]);
                TVector3 IntDir = ClusterCoG(a_tree)-CluPos;
		EClu = a_tree->getEnergy();
		EcalNHit = 0;
		HcalNHit = 0;
		CluNHit = 0;
		EcalEn = 0;
		HcalEn = 0;
                float currDepth = 0;
		maxDepth = -100;
		minDepth = 1E6;
                MaxDisHel = -1;   //maximal distance from Track to Helix
                MinDisHel = 1E10;

                EEClu_R = 0;
                EEClu_r = 0;
                EEClu_p = 0;
                EEClu_L10 = 0;


		std::vector<CalorimeterHit*> Ecalhits;
		std::vector<CalorimeterHit*> Hcalhits;
		std::vector<CalorimeterHit*> allhits;
		std::vector<CalorimeterHit*> EH_1;
		std::vector<CalorimeterHit*> EH_2;
		std::vector<CalorimeterHit*> EH_3;
		std::vector<CalorimeterHit*> EH_4;
                std::vector<CalorimeterHit*> EH_5;
                std::vector<CalorimeterHit*> EH_6;
		std::vector<CalorimeterHit*> HH_1;
		std::vector<CalorimeterHit*> HH_2;
		std::vector<CalorimeterHit*> HH_3;
		std::vector<CalorimeterHit*> HH_4;
		std::vector<CalorimeterHit*> HH_5;
		std::vector<CalorimeterHit*> HH_6;
                std::vector<CalorimeterHit*> HH_7;
                std::vector<CalorimeterHit*> HH_8;
                std::vector<CalorimeterHit*> HH_9;
                std::vector<CalorimeterHit*> HH_0;
                std::vector<CalorimeterHit*> Ecalf10hits;
                std::vector<CalorimeterHit*> Ecall20hits;



		allhits.clear();
		Ecalhits.clear();
		Hcalhits.clear();
		EH_1.clear();
		EH_2.clear();
		EH_3.clear();
		EH_4.clear();
                EH_5.clear();
                EH_6.clear();
		HH_1.clear();
		HH_2.clear();
		HH_3.clear();
		HH_4.clear();
		HH_5.clear();
		HH_6.clear();
                HH_7.clear();
                HH_8.clear();
                HH_9.clear();
                HH_0.clear();
                Ecalf10hits.clear();
                Ecall20hits.clear();


        	HelixClass * currHelix = new HelixClass();
                currHelix->Initialize_Canonical(a_trk->getPhi(), a_trk -> getD0(), a_trk -> getZ0(), a_trk -> getOmega(), a_trk->getTanLambda(), 3.5);  
                float BushDist[3] = {0, 0, 0};
                float BushTime = 0;
		
		std::vector<float> hitTheta;
		hitTheta.clear();
                                
                for(unsigned int j1 = 0; j1 < a_tree->getCalorimeterHits().size(); j1++)
                {
                          CalorimeterHit * a_hit = a_tree->getCalorimeterHits()[j1];
                          BushTime = currHelix->getDistanceToPoint((float*)a_hit->getPosition(), BushDist);
			  TVector3 tmpPos = a_hit->getPosition();
			  hitTheta.push_back(tmpPos.Theta());
                          if(BushTime > 0)
                          {
                                    if(BushDist[2] > MaxDisHel)
                                    {
                                           MaxDisHel = BushDist[2];
                                    }
                                    if(BushDist[2] < MinDisHel)
                                    {
                                           MinDisHel = BushDist[2];
                                    }
                          }
                }
                delete currHelix;

		float totTheta = 0;
		float avTheta = 0;
		float SDTheta;

                for(int t0 = 0; t0 < int(hitTheta.size()); t0++)
                {
                        float tmpTheta = hitTheta[t0];
                        totTheta += tmpTheta;
                }

                avTheta = totTheta/float(hitTheta.size());
                SDTheta = 0;

                for(int t1 = 0; t1 < int(hitTheta.size()); t1++)
                {
                        float tmpTheta = hitTheta[t1];
                        SDTheta += pow(tmpTheta-avTheta,2);
                }
                SDTheta = sqrt(SDTheta/float(hitTheta.size()));

		TVector3 HitPos;
		int currCluNHits = a_tree->getCalorimeterHits().size();
		if(currCluNHits == 0)  CluIDFlag=999;
                CluNHit = currCluNHits;
		int index1 = 0, index2 = 0;

		for(int s1 = 0; s1 < currCluNHits; s1++)
		{
			CalorimeterHit * a_hit = a_tree->getCalorimeterHits()[s1];
			allhits.push_back(a_hit);
			int NLayer = idDecoder(a_hit)["K-1"];

			HitPos = a_hit->getPosition();

			currDepth = DisSeedSurface(HitPos);
			crdis = (CluPos-HitPos).Mag()*sin((CluPos-HitPos).Angle(IntDir));


			if(currDepth > maxDepth)
			{
				maxDepth = currDepth;
				index1 = s1;
			}
			if(currDepth < minDepth)
			{
				minDepth = currDepth;
				index2 = s1;
			}

			if( fabs(a_hit->getEnergy() - DHCALCalibrationConstant) < 1.0E-6 )      //or other fancy judgements...^M
			{
				HcalNHit++;
				HcalEn += a_hit->getEnergy();
				Hcalhits.push_back(a_hit);
				if(NLayer < 5)
				{
					HH_1.push_back(a_hit);
				}
				else if(NLayer < 10)
				{
					HH_2.push_back(a_hit);
				}
				else if(NLayer < 15)
                                {
                                        HH_3.push_back(a_hit);
                                }
                                else if(NLayer < 20)
                                {
                                        HH_4.push_back(a_hit);
                                }
                                else if(NLayer < 25)
                                {
                                        HH_5.push_back(a_hit);
                                }
                                else if(NLayer < 30)
                                {
                                        HH_6.push_back(a_hit);
                                }
				else if(NLayer < 35)
				{
					HH_7.push_back(a_hit);
				}
				else if(NLayer < 40)
				{
					HH_8.push_back(a_hit);
				}
				else if(NLayer < 45)
				{
					HH_9.push_back(a_hit);
				}
				else
				{
					HH_0.push_back(a_hit);
				}
			}
			else
			{
				EcalNHit++;
				EcalEn += a_hit->getEnergy();
				Ecalhits.push_back(a_hit);
                                if(NLayer< 10) Ecalf10hits.push_back(a_hit);
                                else Ecall20hits.push_back(a_hit);
				if(crdis < 22) EEClu_R += a_hit->getEnergy();
                                if(crdis < 11) EEClu_r += a_hit->getEnergy();
                                if(crdis < 6) EEClu_p += a_hit->getEnergy();
				if(NLayer < 5)
				{
					EH_1.push_back(a_hit);
					EEClu_L10 += a_hit->getEnergy();
				}
				else if(NLayer < 10)
				{
					EH_2.push_back(a_hit);
					EEClu_L10 += a_hit->getEnergy();
				}
				else if(NLayer < 15)
                                {
                                        EH_3.push_back(a_hit);
                                } 
				else if(NLayer < 20)
                                {
                                        EH_4.push_back(a_hit);
                                } 
				else if(NLayer < 25)
                                {
                                        EH_5.push_back(a_hit);
                                }
				else
				{
					EH_6.push_back(a_hit);
				}
			}
		}
                
		if(a_tree->getCalorimeterHits().size()>0){
		CalorimeterHit * maxdis_hit = a_tree->getCalorimeterHits()[index1];
		CalorimeterHit * mindis_hit = a_tree->getCalorimeterHits()[index2];
		TVector3 maxpos = maxdis_hit->getPosition();
		TVector3 minpos = mindis_hit->getPosition();
		TVector3 GraPos = ClusterCoG(a_tree);
		graDepth = DisSeedSurface(GraPos);
		cluDepth = (maxpos-minpos).Mag();
		graAbsDepth = (GraPos-minpos).Mag();



		maxDisHtoL = -100;
		minDisHtoL = 1E6;

		float totDisHtoL = 0;

		float totHitEn = 0;
		float totHitEnDis = 0;
		float HitEn;

		for(int s2 = 0; s2 < currCluNHits; s2++)
		{
			CalorimeterHit * a_hit2 = a_tree->getCalorimeterHits()[s2];
			HitPos = a_hit2->getPosition();
			HitEn  = a_hit2->getEnergy();
			TVector3 par1 = GraPos-minpos;
			TVector3 par2 = minpos-HitPos;
			TVector3 par3 = par1.Cross(par2);
			float disHtoL = par3.Mag()/par1.Mag();
			totDisHtoL+=disHtoL;
			totHitEn+=HitEn;
			totHitEnDis+=HitEn*disHtoL;
			if (disHtoL > maxDisHtoL) maxDisHtoL = disHtoL;
			if (disHtoL < minDisHtoL) minDisHtoL = disHtoL;

		}
		avDisHtoL = totDisHtoL/currCluNHits;
		avEnDisHtoL = totHitEnDis/totHitEn;
		FD_all = FDV2(allhits, ECALCellIDDecoder);
		FD_ECAL = FDV2(Ecalhits, ECALCellIDDecoder);
		FD_HCAL = FDV2(Hcalhits, ECALCellIDDecoder);
                FD_ECALF10 = FDV2(Ecalf10hits, ECALCellIDDecoder);
                NH_ECALF10 = Ecalf10hits.size();
                FD_ECALL20 = FDV2(Ecall20hits, ECALCellIDDecoder);
                NH_ECALL20 = Ecall20hits.size();

		NLEcal = 0;
		NLHcal = 0;
		for(int p0 = 0; p0 < 8; p0++)
                {
                	NH[p0] = 0;
                        NL[p0] = 0;
                        FD[p0] = 0;
                }

		FD[0] = FDV2(EH_1, ECALCellIDDecoder);
		FD[1] = FDV2(EH_2, ECALCellIDDecoder);
		FD[2] = FDV2(EH_3, ECALCellIDDecoder);
		FD[3] = FDV2(EH_4, ECALCellIDDecoder);
		FD[4] = FDV2(EH_5, ECALCellIDDecoder);
		FD[5] = FDV2(EH_6, ECALCellIDDecoder);
		FD[6] = FDV2(HH_1, ECALCellIDDecoder);
		FD[7] = FDV2(HH_2, ECALCellIDDecoder);
		FD[8] = FDV2(HH_3, ECALCellIDDecoder);
		FD[9] = FDV2(HH_4, ECALCellIDDecoder);
		FD[10] = FDV2(HH_5, ECALCellIDDecoder);
		FD[11] = FDV2(HH_6, ECALCellIDDecoder);
		FD[12] = FDV2(HH_7, ECALCellIDDecoder);
		FD[13] = FDV2(HH_8, ECALCellIDDecoder);
		FD[14] = FDV2(HH_9, ECALCellIDDecoder);
		FD[15] = FDV2(HH_0, ECALCellIDDecoder);

		NH[0] = EH_1.size();
		NH[1] = EH_2.size();
		NH[2] = EH_3.size();
		NH[3] = EH_4.size();
		NH[4] = EH_5.size();
		NH[5] = EH_6.size();
		NH[6] = HH_1.size();
		NH[7] = HH_2.size();
		NH[8] = HH_3.size();
		NH[9] = HH_4.size();
		NH[10] = HH_5.size();
		NH[11] = HH_6.size();
		NH[12] = HH_7.size();
		NH[13] = HH_8.size();
                NH[14] = HH_9.size();
                NH[15] = HH_0.size();

		NLEcal = ActiveLayers(Ecalhits, ECALCellIDDecoder);
		NLHcal = ActiveLayers(Hcalhits, ECALCellIDDecoder);
		NL[0] = ActiveLayers(EH_1, ECALCellIDDecoder);
		NL[1] = ActiveLayers(EH_2, ECALCellIDDecoder);
		NL[2] = ActiveLayers(EH_3, ECALCellIDDecoder);
		NL[3] = ActiveLayers(EH_4, ECALCellIDDecoder);
		NL[4] = ActiveLayers(EH_5, ECALCellIDDecoder);
		NL[5] = ActiveLayers(EH_6, ECALCellIDDecoder);
		NL[6] = ActiveLayers(HH_1, ECALCellIDDecoder);
		NL[7] = ActiveLayers(HH_2, ECALCellIDDecoder);
		NL[8] = ActiveLayers(HH_3, ECALCellIDDecoder);
		NL[9] = ActiveLayers(HH_4, ECALCellIDDecoder);
		NL[10] = ActiveLayers(HH_5, ECALCellIDDecoder);
		NL[11] = ActiveLayers(HH_6, ECALCellIDDecoder);
		NL[12] = ActiveLayers(HH_7, ECALCellIDDecoder);
		NL[13] = ActiveLayers(HH_8, ECALCellIDDecoder);
		NL[14] = ActiveLayers(HH_9, ECALCellIDDecoder);
		NL[15] = ActiveLayers(HH_0, ECALCellIDDecoder);

	

		float sum_NHE = 0, sum_NHH = 0;
                av_NHE = 0;
                av_NHH = 0;
                AL_Ecal = 0;
                AL_Hcal = 0;

                for(int r1 = 0; r1 < 16; r1++)
		{
			if(r1 < 6 && NH[r1]>0)
                        {
                                sum_NHE += NH[r1];
                                AL_Ecal++;
                        }
                        if(r1 >= 6 && NH[r1]>0)
                        {
                                sum_NHH += NH[r1];
                                AL_Hcal++;
                        }
                }
                if(AL_Ecal > 0)
                        av_NHE = sum_NHE/AL_Ecal;
                if(AL_Hcal > 0)
                        av_NHH = sum_NHH/AL_Hcal;

                rms_Ecal = 0;
                rms_Hcal = 0;
		rms_Ecal2 = 0;
		rms_Hcal2 = 0;	
                for(int r0 = 0; r0 < 16; r0++)
                {
                        if(r0 < 6)
                        {
                                if(NH[r0] > 0)
                                {
                                        rms_Ecal+=pow(NH[r0]-av_NHE,2);
                                        rms_Ecal2 += pow(NH[r0],2);
                                }
                        }
                        else
                        {
                                if(NH[r0] > 0)
                                {
                                        rms_Hcal+=pow(NH[r0]-av_NHH,2);
                                        rms_Hcal2 += pow(NH[r0],2);
                                }
                        }
                }
                if(AL_Ecal > 0)
                {
                        rms_Ecal2 = sqrt(rms_Ecal2/AL_Ecal);
                        rms_Ecal = sqrt(rms_Ecal/AL_Ecal);
                }
                else
                {
                        rms_Ecal2 = -1;
                        rms_Ecal = -1;
                }
                if(AL_Hcal > 0)
                {
                        rms_Hcal2 = sqrt(rms_Hcal2/AL_Ecal);
                        rms_Hcal = sqrt(rms_Hcal/AL_Ecal);
                }
                else
                {
                        rms_Hcal2 = -1;
                        rms_Hcal = -1;
                }
		}
		int level=0;
		int bin[]={1,2,3,5,7,10,20,30,40,50,70};
		float en[]={0.0, 1.5,2.5, 4, 6, 8.5, 15,25, 35,45,60, 99999};
		TMVA::Reader *reader;
		for(int i=0;i<11;i++){
			if(TrackEn>en[i]&&TrackEn<en[i+1]){level=bin[i];
				reader=reader_all[i];
			}
		}
		//TMVA::Reader *reader;
      		//TString wgtFname;
	
   		//TString dir = "/scratchfs/higgs/yudan/PID/";
   		//TString slevel = Form("%d",level);
   		//wgtFname = dir + "TMVA_"+ slevel +"GeV/weights/TMVAMulticlass_BDTG.weights.xml";

		//TMVA::Tools::Instance();
   		//reader = new TMVA::Reader( "!Color:Silent" );
		//float _EcalNHit=(float)EcalNHit;
		//float _HcalNHit=(float)HcalNHit;
		//float _NLEcal=(float)NLEcal;
		//float _NLHcal=(float)NLHcal;
		//float _av_NHH=(float)av_NHH;
		//float _AL_Ecal=(float)AL_Ecal;
		//float _NH_ECALF10=(float)NH_ECALF10;
		//float EE, E_10, E_R, E_r;
		//reader->AddVariable("EcalNHit", &_EcalNHit);
		//reader->AddVariable("HcalNHit", &_HcalNHit);
		//reader->AddVariable("NLEcal", &_NLEcal);
		//reader->AddVariable("NLHcal", &_NLHcal);
		//reader->AddVariable("maxDisHtoL",&maxDisHtoL);
		//reader->AddVariable("avDisHtoL",&avDisHtoL);
		//reader->AddVariable("EE := EcalEn/EClu",&EE);
		//reader->AddVariable("graDepth",&graDepth);
		//reader->AddVariable("cluDepth",&cluDepth);
		//reader->AddVariable("minDepth",&minDepth);
		//reader->AddVariable("MaxDisHel",&MaxDisHel);
		//reader->AddVariable("FD_all",&FD_all);
		//reader->AddVariable("FD_ECAL",&FD_ECAL);
		//reader->AddVariable("FD_HCAL",&FD_HCAL);
		//reader->AddVariable("E_10 := EEClu_L10/EcalEn",&E_10);
		//reader->AddVariable("E_R := EEClu_R/EcalEn",&E_R);
		//reader->AddVariable("E_r := EEClu_r/EcalEn",&E_r);
		//reader->AddVariable("rms_Hcal",&rms_Hcal);
		//reader->AddVariable("rms_Hcal2",&rms_Hcal2);
		//reader->AddVariable("av_NHH", &_av_NHH);
		//reader->AddVariable("AL_Ecal", &_AL_Ecal);
		//reader->AddVariable("FD_ECALF10",&FD_ECALF10);
		//reader->AddVariable("FD_ECALL20",&FD_ECALL20);
		//reader->AddVariable("NH_ECALF10", &_NH_ECALF10);
		//reader->AddVariable("dEdx",&dEdx);
	
		//E_R=EEClu_R/EcalEn;
		//E_r=EEClu_r/EcalEn;
		//E_10=EEClu_L10/EcalEn;
		//EE=EcalEn/EClu;
   		//reader->BookMVA("BDTG", wgtFname);

   		mvaVal_pi=0.;
   		mvaVal_mu=0.;
   		mvaVal_e=0.;
   		int mvaVal=0;

   		mvaVal_pi = (reader->EvaluateMulticlass("BDTG"))[0];
   		mvaVal_mu = (reader->EvaluateMulticlass("BDTG"))[1];
   		mvaVal_e = (reader->EvaluateMulticlass("BDTG"))[2];
		cout<<mvaVal_pi<<" "<<mvaVal_mu<<" "<<mvaVal_e<<endl;
		if(mvaVal_e>mvacut_e&&mvaVal_mu<mvacut_mu&&mvaVal_pi<mvacut_pi){
   				mvaVal=11;
			}
		if(mvaVal_pi>mvacut_pi&&mvaVal_mu<mvacut_mu&&mvaVal_e<mvacut_e){
   			mvaVal=211;
		}
		if(mvaVal_mu>mvacut_mu&&mvaVal_pi<mvacut_pi&&mvaVal_e<mvacut_e){
			mvaVal=13;
		}
   		


		//delete reader;

                if(mvaVal==11) ClusterID = 11;
                else if (mvaVal==13)  ClusterID = 13;
		else if (mvaVal==211)  ClusterID = 211;

		if(ClusterID == 13 )
		{
			if(NLEcal+NLHcal < 30) CluIDFlag = 131;
			else CluIDFlag = 130;
		}

		if(ClusterID == 11 )
		{
			if(EClu < 0.8*TrackEn) CluIDFlag = 111;
			else CluIDFlag = 110;
		}

		if(ClusterID == 211 )
		{
			if(EClu < 0.8*TrackEn) CluIDFlag = 212;
			else CluIDFlag = 211;
		}




	}

}


void BushConnect::TrackSort(LCEvent* evtPP) //, &std::map<Track*, int>Track_Tpye, &std::map<Track*, float> Track_Energy)
{
	

	LCCollection * TrackColl = evtPP->getCollection("MarlinTrkTracks");

	int NTrk = TrackColl->getNumberOfElements();
	float D0 = 0;
	float Z0 = 0;
	int NTrkHit = 0;
	const float mass = 0.139;	//Pion Mass
	TVector3 EndPointPos, StartPointPos; 
	int TrackType = 0; 

	std::vector<Track*> tracks_HQ_Barrel; 
	std::vector<Track*> tracks_HQ_Endcap;
	std::vector<Track*> tracks_HQ_Shoulder;
	std::vector<Track*> tracks_HQ_Forward; 
	std::vector<Track*> tracks_MQ_Barrel;
	std::vector<Track*> tracks_MQ_Endcap;
	std::vector<Track*> tracks_MQ_Shoulder;
	std::vector<Track*> tracks_MQ_Forward;
	std::vector<Track*> tracks_Vtx; 
	std::vector<Track*> tracks_LQ; 
	std::vector<Track*> curr_tracks;

	trkendposition.clear();

	tracks_HQ_Barrel.clear();
	tracks_HQ_Endcap.clear();
	tracks_HQ_Shoulder.clear();
	tracks_HQ_Forward.clear();
	tracks_MQ_Barrel.clear();
	tracks_MQ_Endcap.clear();
	tracks_MQ_Shoulder.clear();
	tracks_MQ_Forward.clear();
	tracks_Vtx.clear();
	tracks_LQ.clear();

	std::vector<Track*> tracks_ILL;
	tracks_ILL.clear();
	std::vector<Track*> tracks_preInteraction;
	tracks_preInteraction.clear();	//Used to denote pion and electron interaction inside TPC/Tracker. Simply vetoed for avoid double counting... but muon may still be problematic. Better way of treating would be find the cascade photons & tracks - clusters, and veto all the daughters instead of mother. Similar can done for Kshort...
	// Condition, tracks_head to others tail. head position far from boundary. and, track energy >= sum of cascade

	std::vector<int> TrackOrder; 
	TrackOrder.clear();	
	std::map<Track*, int> Track_Index; 
	Track_Index.clear();
	Track_Energy.clear();
	Track_Type.clear();


	std::map<Track*, TVector3> TrackEndPoint;	//Last hit
	std::map<Track*, TVector3> TrackStartPoint;	//First hit
	TrackEndPoint.clear();
	TrackStartPoint.clear();

	for(int i0 = 0; i0 < NTrk; i0++)
	{
		Track* a_Trk = dynamic_cast<Track*>( TrackColl->getElementAt( i0 ) );
		NTrkHit = a_Trk->getTrackerHits().size();		
		EndPointPos = (a_Trk->getTrackerHits()[NTrkHit - 1])->getPosition();	
		StartPointPos = (a_Trk->getTrackerHits()[0])->getPosition();
		TrackEndPoint[a_Trk] = EndPointPos;
		TrackStartPoint[a_Trk] = StartPointPos;

		HelixClass * TrkInit_Helix = new HelixClass();
		TrkInit_Helix->Initialize_Canonical(a_Trk->getPhi(), a_Trk -> getD0(), a_Trk -> getZ0(), a_Trk -> getOmega(), a_Trk->getTanLambda(), BField);
		float TrackEn = mass*mass;

		for (int q3 = 0; q3 < 3; q3 ++)
		{
			TrackEn += (TrkInit_Helix->getMomentum()[q3])*(TrkInit_Helix->getMomentum()[q3]);
		}

		TrackEn = sqrt(TrackEn);
		Track_Energy[a_Trk] = TrackEn;

		delete TrkInit_Helix;
	}

	TVector3 currEp, currSp;
	float currMotherEn = 0;
	float sumDauEn = 0; 
	int NDaughter = 0; 
	int outputflag = 0; 

	for(int i1 = 0; i1 < NTrk; i1++)
	{
		Track* a_Trk = dynamic_cast<Track*>( TrackColl->getElementAt( i1 ) );		
		currEp = TrackEndPoint[a_Trk];
		outputflag = 0;

		if( currEp.Perp() < 1600 && currEp.Perp() > 400 && abs(currEp.Z()) < 2000 )	//Only check 
		{
			currMotherEn = Track_Energy[a_Trk];
			sumDauEn = 0;	
			NDaughter = 0; 
			for(int i2 = 0; i2 < NTrk; i2++)
			{
				Track* b_Trk = dynamic_cast<Track*>( TrackColl->getElementAt( i2 ) );
				if(i2 != i1)
				{
					currSp = TrackStartPoint[b_Trk];
					if( (currEp - currSp).Mag() < 40  )
					{
						sumDauEn += Track_Energy[b_Trk];
						NDaughter ++;
					}
				}
			}
			if( currMotherEn + 0.1 > 0.9*sumDauEn && currMotherEn > 2 && NDaughter > 0 )	//Some protection is always needed...
			{
				// tracks_preInteraction.push_back(a_Trk);

				if(NDaughter > 1 || currMotherEn > 10)
				{
					tracks_preInteraction.push_back(a_Trk);
					outputflag = 1; 
				}
				else if(NDaughter == 1 && currMotherEn < 5)	//Maybe Pion Decay
				{
					tracks_preInteraction.push_back(a_Trk); // Problematic as we might lost the Cluster. 
					outputflag = 1; 
				}

//				if(outputflag)
					//cout<<"PPPPPPPPPPPPPPPPPPPRRRRRRRRRRRRRRRRRRRRRRinteraction Track found "<<currMotherEn<<" to "<<sumDauEn<<" ND "<<NDaughter<<endl; 
			}
		}
	}

	for(int t0 = 0; t0 < NTrk; t0++)
	{
		Track* a_Trk = dynamic_cast<Track*>( TrackColl->getElementAt( t0 ) );
		D0 = a_Trk->getD0();
		Z0 = a_Trk->getZ0();
		NTrkHit = a_Trk->getTrackerHits().size();
		TrackerHit * last_hit = a_Trk->getTrackerHits()[NTrkHit - 1];
		EndPointPos = last_hit->getPosition();
		trkendposition[a_Trk] = EndPointPos;
		StartPointPos = (a_Trk->getTrackerHits()[0])->getPosition();
		Track_Index[a_Trk] = t0;

		if( NTrkHit > 9 || (fabs(EndPointPos.Z()) > LStar - 500 && EndPointPos.Perp() < TPCInnerRadius ) || fabs(EndPointPos.Z()) > ECALHalfZ - 200  )		// Min requirement for track quality
		{	// LStar - 500, suppose to be the last Disk Position

			if( find(tracks_preInteraction.begin(), tracks_preInteraction.end(), a_Trk ) != tracks_preInteraction.end() )
			{
				//cout<<"So We Drop it! "<<Track_Energy[a_Trk]<<endl; 
				continue; 
			}

			TrackType = 0;

			if( fabs(EndPointPos.Z()) > ECALHalfZ - 500 && EndPointPos.Perp() > TPCOuterRadius - 300  )	//Shoulder
			{
				TrackType = 30;
			}
			else if( fabs(EndPointPos.Z()) > LStar - 500 && EndPointPos.Perp() < TPCInnerRadius )		//Forward
			{
				TrackType = 40;
			}
			else if( EndPointPos.Perp() > TPCOuterRadius - 100 )		//Barrel
			{
				TrackType = 10;
			}
			else if( fabs(EndPointPos.Z()) > ECALHalfZ - 200 )		//Endcap
			{
				TrackType = 20; 
			}

			if( fabs(D0) < 1 && fabs(Z0) < 1 )
			{
				TrackType += 1;
			}

			Track_Type[a_Trk] = TrackType; 

			if(TrackType == 11)
				tracks_HQ_Barrel.push_back(a_Trk);
			else if(TrackType == 21)
				tracks_HQ_Endcap.push_back(a_Trk);
			else if(TrackType == 31)
				tracks_HQ_Shoulder.push_back(a_Trk);
			else if(TrackType == 41)
				tracks_HQ_Forward.push_back(a_Trk);
			else if(TrackType == 10)
				tracks_MQ_Barrel.push_back(a_Trk);
			else if(TrackType == 20)
				tracks_MQ_Endcap.push_back(a_Trk);
			else if(TrackType == 30)
				tracks_MQ_Shoulder.push_back(a_Trk);
			else if(TrackType == 40)
				tracks_MQ_Forward.push_back(a_Trk);
			else if(TrackType == 1)
				tracks_Vtx.push_back(a_Trk);
			else if( StartPointPos.Mag() > 50 && EndPointPos.Mag() < 1000 && NTrkHit < 50  )
				tracks_ILL.push_back(a_Trk);
			else
				tracks_LQ.push_back(a_Trk);
		}
	}

	std::vector<float > currTrkMomentum;
	std::vector<int> currTrkIndex;

	for(int t1 = 0; t1 < 10; t1++)
	{
		currTrkMomentum.clear();
		currTrkIndex.clear();
		curr_tracks.clear();
		if(t1 == 0)
			curr_tracks = tracks_HQ_Endcap;
		else if(t1 == 1)
			curr_tracks = tracks_HQ_Barrel;
		else if(t1 == 2)
			curr_tracks = tracks_MQ_Endcap;
		else if(t1 == 3)
			curr_tracks = tracks_MQ_Barrel;
		else if(t1 == 4)
			curr_tracks = tracks_HQ_Shoulder;
		else if(t1 == 5)
			curr_tracks = tracks_MQ_Shoulder;
		else if(t1 == 6)
			curr_tracks = tracks_HQ_Forward;
		else if(t1 == 7)
			curr_tracks = tracks_MQ_Forward;
		else if(t1 == 8)
			curr_tracks = tracks_Vtx;
		else if(t1 == 9)			
			curr_tracks = tracks_LQ; 

		int N_currTrack = curr_tracks.size();

		for(int t2 = 0; t2 < N_currTrack; t2++)
		{
			Track* tmpTrk = curr_tracks[t2];

			currTrkMomentum.push_back(Track_Energy[tmpTrk]);
		}

		currTrkIndex = SortMeasure(currTrkMomentum, 1);

		for(int t3 = 0; t3 < N_currTrack; t3++)
		{
			Track* b_tmpTrk = curr_tracks[currTrkIndex[t3]];
			if(t1 < 9 || Track_Energy[b_tmpTrk] < 10)
				TrackOrder.push_back(Track_Index[b_tmpTrk]);
		}
	}

	for(unsigned int t4 = 0; t4 < TrackOrder.size(); t4++)
	{
		Track* b_Trk = dynamic_cast<Track*>( TrackColl->getElementAt( TrackOrder[t4] ) );
		SortedTracks.push_back(b_Trk);
	}
}

void CheckConsistence(LCEvent *evtQQ, std::vector<std::string> SubClass)
{
	float inputEn = 0;
	int inputNCl = 0;
	float TotalEn = 0;
	int TotalNCl = 0;

	for(int c1 = 0; c1 < int(SubClass.size()); c1++)
	{

		LCCollection * LocalCol = evtQQ->getCollection( SubClass[c1].c_str() );

		int CurrCollSize = LocalCol->getNumberOfElements();
		float CurrEnergy = 0;

		for(int c2 = 0; c2 < CurrCollSize; c2++)
		{
			Cluster * a_clu = dynamic_cast<Cluster*>(LocalCol->getElementAt(c2));
			CurrEnergy += a_clu->getEnergy();
		}

		if(c1 < 2)
		{
			inputEn += CurrEnergy;
			inputNCl += CurrCollSize;
		}
		else
		{
			TotalNCl += CurrCollSize;
			TotalEn += CurrEnergy;
		}

		//cout<<"CurrColl "<<SubClass[c1].c_str()<<" has "<<CurrCollSize<<" Clusters with total En = "<<CurrEnergy<<" GeV"<<endl;
	}

	//cout<<endl<<"Comparison Energy "<<inputEn<<" =? "<<TotalEn<<endl;
	//cout<<"Comparison Cluster Size "<<inputNCl<<" =? "<<TotalNCl<<endl<<endl;
}

void BushConnect::BushSelfMerge(LCEvent * evtPP)
{
	LCCollection * CaloClu = evtPP->getCollection("EHBushes");      //A sort here should be helpful
	int NClu = CaloClu->getNumberOfElements();

	std::vector<Cluster* > Core_1st; 
	std::vector<Cluster* > Frag_1st;
	std::vector<Cluster* > UnId_1st; 
	Core_1st.clear();
	Frag_1st.clear();
	UnId_1st.clear();

	float CluDepth = 0; 
	float CluEn = 0;
	int CluSize = 0; 
	TVector3 PosCluSeed, PosSeedDiff, PosSeedA, PosSeedB; 

	// Maybe first ID? Should be helpful

	float TotalCluEn = 0;
	float TotalCluEn_1stAB = 0;

	int NJoints = 0; 	
	int SmallCluSize = 0; 
	float Depth_A = 0; 
	float Depth_B = 0;
	int Size_A = 0; 
	int Size_B = 0; 

	TMatrixF FlagMerge(NClu, NClu);

	for(int i0 = 0; i0 < NClu; i0++)
	{
		Cluster * a_clu = dynamic_cast<Cluster*>(CaloClu->getElementAt(i0));
		float currCluFD = FDV3(a_clu, ECALCellIDDecoder);
		CluFD[a_clu] = currCluFD;
		//cout<<currCluFD<<" FD:NHit "<<a_clu->getCalorimeterHits().size()<<endl; 
	}

	for(int s0 = 0; s0 < NClu; s0++)
	{
		Cluster * a_clu = dynamic_cast<Cluster*>(CaloClu->getElementAt(s0));
		PosSeedA = a_clu->getPosition();
		Depth_A = DisSeedSurface(PosSeedA);
		Size_A = a_clu->getCalorimeterHits().size();

		for(int s1 = s0 + 1; s1 < NClu; s1++)
		{
			Cluster *b_clu = dynamic_cast<Cluster*>(CaloClu->getElementAt(s1));
			NJoints = JointsBetweenBush(a_clu, b_clu, 4);
			PosSeedB = b_clu->getPosition();
			Depth_B = DisSeedSurface(PosSeedB);
			PosSeedDiff = PosSeedA - PosSeedB;
			Size_B = a_clu->getCalorimeterHits().size();
			float DeeperDepth = std::max(Depth_A, Depth_B);
			if(NJoints && PosSeedDiff.Perp() < 120 + 0.05*DeeperDepth )	//And depth...
			{
				SmallCluSize = std::min( Size_A, Size_B );

				if( ( ( NJoints > 4 || (NJoints > 1 && SmallCluSize < 10) ) && DeeperDepth > 30 ) || NJoints > 8 )
				{	
					FlagMerge[s0][s1] = 1.0;
					FlagMerge[s1][s0] = 1.0;
				}
			}
			//Head Tail Connection. Could be more sophsticate && should be very strict.
			if( PosSeedA.Angle(PosSeedB) < 0.1 && PosSeedDiff.Mag() < 1000 && PosSeedDiff.Mag()*PosSeedA.Angle(PosSeedB) < 60 + 0.02*DeeperDepth && ((CluFD[a_clu] < 0.2 && Size_A > 6) || (CluFD[b_clu] < 0.2 && Size_B > 6)) )
			{
				if( (PosSeedA.Mag() > PosSeedB.Mag() && PosSeedA.Angle(PosSeedB - PosSeedA) < 0.2) || (PosSeedB.Mag() > PosSeedA.Mag() && PosSeedA.Angle(PosSeedA - PosSeedB) < 0.2) )
				{
					FlagMerge[s0][s1] = 2.0;
					FlagMerge[s1][s0] = 2.0;
					//cout<<"tail found"<<endl; 
				}
			}

			//Check if Head-Tail Connection

			// if( CluFD[a_clu] < 0.2 || CluFD[b_clu] < 0.2 )	// Applied 
			{
				std::pair<TVector3, TVector3> PointPair = ClosestPointPair(a_clu, b_clu);
				//cout<<"CLOSESSSSSSSSSSSSSSSSSSSS Pair"<< (PointPair.first - PointPair.second).Mag() <<endl; 
				//cout<<PointPair.first.X()<<" : "<<PointPair.first.Y()<<" : "<<PointPair.first.Z()<<endl;
				//cout<<PointPair.second.X()<<" : "<<PointPair.second.Y()<<" : "<<PointPair.second.Z()<<endl;

				TVector3 CoGDeep, CoGShallow;
				if( PointPair.first.Mag() < PointPair.second.Mag() )
				{
					CoGDeep = ClusterCoG(b_clu);
					CoGShallow = ClusterCoG(a_clu);
					
					//cout<<"AB " <<(CoGDeep - PointPair.second).Angle(PointPair.second - PointPair.first)<<endl; 
				}
				else
				{
					CoGDeep = ClusterCoG(a_clu);
                                        CoGShallow = ClusterCoG(b_clu);
                                        
                                        //cout<<"BA " <<(CoGDeep - PointPair.first).Angle(PointPair.first - PointPair.second)<<endl;
				}
			}
		}
		TotalCluEn += a_clu->getEnergy();
	}

	std::vector<Cluster*> OriInputEHBushes = CollClusterVec(CaloClu);
	TMatrixF MergeSYM = MatrixSummarize(FlagMerge);
	LCCollection* CloseMergedCaloClu = ClusterVecMerge( OriInputEHBushes, MergeSYM);

	// 1st iteration absorbtion: large energy threshold, and small merge region, keep purity

	std::map<Cluster*,float> MinDisSeedToBush;
	MinDisSeedToBush.clear();
	for(int i0 = 0; i0 < CloseMergedCaloClu->getNumberOfElements(); i0++)
	{
		Cluster * a_clu = dynamic_cast<Cluster*>(CloseMergedCaloClu->getElementAt(i0));
		PosCluSeed = a_clu->getPosition();
		float tmpmindis = 1e10;
		for(int i1 = 0; i1 < CloseMergedCaloClu->getNumberOfElements(); i1++)
		{
			Cluster * b_clu = dynamic_cast<Cluster*>(CloseMergedCaloClu->getElementAt(i1));
			if(i1 != i0)
			{
				if(DisPointToBush(PosCluSeed,b_clu) < tmpmindis) tmpmindis = DisPointToBush(PosCluSeed,b_clu);  
			}
		}
		MinDisSeedToBush[a_clu] = tmpmindis;
	}

	for(int i0 = 0; i0 < CloseMergedCaloClu->getNumberOfElements(); i0++)
	{
		Cluster * a_clu = dynamic_cast<Cluster*>(CloseMergedCaloClu->getElementAt(i0));
		PosCluSeed = a_clu->getPosition();
		CluDepth = DisSeedSurface(PosCluSeed);
		CluEn = a_clu->getEnergy();
		CluSize = a_clu->getCalorimeterHits().size();

		if( CluEn > 2.5 + 0.003*CluDepth || (CluSize > 10 && CluDepth < 20) )
		{
			Core_1st.push_back(a_clu);
		}
		else if( PhotonTag(a_clu) == 1 && (CluSize > 10 || CluEn > 0.2) && MinDisSeedToBush[a_clu] > 20 && CluDepth < 25 )
		{
			Core_1st.push_back(a_clu);
		}
		else if( CluSize < 5 && CluEn < 0.3 && CluDepth > 40 )
		{
			Frag_1st.push_back(a_clu);
		}
		else
		{
			UnId_1st.push_back(a_clu);
		}
	}

	std::vector<Cluster* > UndefFrag_1stAB = ClusterAbsorbtion(UnId_1st, Frag_1st, 50, 0.02);
	std::vector<Cluster* > CoreFrag_1stAB = ClusterAbsorbtion(Core_1st, UndefFrag_1stAB, 50, 0.02);	

	// cout<<"TTTTTTTT, UnId, Frag, Core "<<UnId_1st.size()<<" : "<<Frag_1st.size()<<" : "<<Core_1st.size()<<"   AAAAAAAAAAAAAF "<<UndefFrag_1stAB.size()<<" > "<<CoreFrag_1stAB.size()<<endl;

	float MaxCluEn = 0;

	for(int s = 0; s < int(CoreFrag_1stAB.size()); s++)
	{
		Cluster * a_clu = CoreFrag_1stAB[s];
		TotalCluEn_1stAB += a_clu->getEnergy();
		if(MaxCluEn < a_clu->getEnergy())
			MaxCluEn = a_clu->getEnergy();
	}
	// cout<<"EnCompare "<<NClu<<" : "<<CoreFrag_1stAB.size()<<" & En "<<TotalCluEn<<" =? "<<TotalCluEn_1stAB<<" Leading Clu "<<MaxCluEn<<endl;

	// 2nd iteration, considering the cores

	std::vector<Cluster* > Core_2nd;
	std::vector<Cluster* > Frag_2nd;
	std::vector<Cluster* > UnId_2nd;
	Core_2nd.clear();
	Frag_2nd.clear();
	UnId_2nd.clear();

	std::map<Cluster*,float> MinDisSeedToBush2;
	MinDisSeedToBush2.clear();
	for(int i0 = 0; i0 < int(CoreFrag_1stAB.size()); i0++)
	{
		Cluster * a_clu = CoreFrag_1stAB[i0];
		PosCluSeed = a_clu->getPosition();
		float tmpmindis = 1e10;
		for(int i1 = 0; i1 < int(CoreFrag_1stAB.size()); i1++)
		{
			Cluster * b_clu = CoreFrag_1stAB[i1];
			if(i1 != i0)
			{
				if(DisPointToBush(PosCluSeed,b_clu) < tmpmindis) tmpmindis = DisPointToBush(PosCluSeed,b_clu);
			}
		}
		MinDisSeedToBush2[a_clu] = tmpmindis;
	}

	for(int i2 = 0; i2 < int(CoreFrag_1stAB.size()); i2++)
	{
		Cluster * a_clu = CoreFrag_1stAB[i2];
		PosCluSeed = a_clu->getPosition();
		CluDepth = DisSeedSurface(PosCluSeed);
		CluEn = a_clu->getEnergy();
		CluSize = a_clu->getCalorimeterHits().size();
		if( CluEn > 1.5 + 0.003*CluDepth || (PhotonTag(a_clu) == 1 && (CluSize > 10 || CluEn > 0.2) && MinDisSeedToBush2[a_clu] > 20 && CluDepth < 25) )
		{
			Core_2nd.push_back(a_clu);
		}
		else
		{
			UnId_2nd.push_back(a_clu);
		}
	}	

	float MinDisToCore = 1.0E10; 
	float tmpUnIdCoreDis = 1.0E10; 

	for(int i3 = 0; i3 < int(UnId_2nd.size()); i3++)
	{
		Cluster * a_unId = UnId_2nd[i3];
		CluEn = a_unId->getEnergy();
		PosCluSeed = a_unId->getPosition();
		CluDepth = DisSeedSurface(PosCluSeed);
		CluSize = a_unId->getCalorimeterHits().size();
		MinDisToCore = 1.0E10;
		tmpUnIdCoreDis = 1.0E10;

		for(int j3 = 0; j3 < int(Core_2nd.size()); j3++)
		{
			Cluster *a_core = Core_2nd[j3];
			tmpUnIdCoreDis = BushDis(a_core, a_unId);	//Maybe Giveback the vector is even better. Surely!
			if( tmpUnIdCoreDis < MinDisToCore )
			{
				MinDisToCore = tmpUnIdCoreDis;
			}			
		}
		if( (1 - 0.0006*CluDepth) * CluEn * MinDisToCore > 30 )	//function and para need to be optimized, Projective distance should make more sense
		{	
			Core_2nd.push_back(a_unId);
		}
		else
		{
			Frag_2nd.push_back(a_unId);	//Should be merged to the minimal index one...
		}
	}

	// cout<<"SSSSSSSSize "<<Core_2nd.size()<<" : "<<Frag_2nd.size()<<endl; 
	std::vector<Cluster* > CoreFrag_2ndAB = ClusterAbsorbtion(Core_2nd, Frag_2nd, 50, 0.02);

	LCCollection *SMBush_2nd = ClusterVecColl(CoreFrag_2ndAB);
	evtPP->addCollection(SMBush_2nd, "SMBush_2ndIt");
	SortedSMBushes = CollClusterVec(SMBush_2nd);
	//Set ID...
}

void BushConnect::BushTrackMatch(LCEvent * evtPP) //Finding NEMO
{
	LCCollection * col_TPCTrk = evtPP->getCollection("ClupatraTracks");

	int NClu = SortedSMBushes.size(); //CaloClu->getNumberOfElements();
	int NTrk = SortedTracks.size();
	std::map<Cluster*, int> TouchFlag_EHBushes;
	TouchFlag_EHBushes.clear();

	LCCollection *arborcore_ch = new LCCollectionVec(LCIO::RECONSTRUCTEDPARTICLE);  //Tight ones test
	LCCollection *arborcore_ne = new LCCollectionVec(LCIO::RECONSTRUCTEDPARTICLE);
	arborcore_ch->setFlag(Cluflag.getFlag());
	arborcore_ne->setFlag(Cluflag.getFlag());

	std::vector<Cluster* > tmpChargedCore;
	std::vector<Cluster* > ChargedCore_Tight;       // ChargedCore that has trk endp hit
	std::vector<Cluster* > ChargedCore_Medium;      // ChargedCore that has no endp, but closest to tracks
	std::vector<Cluster* > NeutralCore_0;           // Energetic
	std::vector<Cluster* > PhotonCore_0;
	std::vector<Cluster* > NHCore_0;

	std::vector<Cluster* > NeutralCore_1;
	std::vector<Cluster* > NeutralCore_2;

	std::vector<Cluster*> ChCluVec;
	ChCluVec.clear();

	TVector3 CluSeedPos;

	for(int i = 0; i < NClu; i++)
	{
		Cluster * a_clu = SortedSMBushes[i];    //dynamic_cast<Cluster* > (CaloClu->getElementAt(i));
		CluSeedPos = a_clu->getPosition();      //Energy Constrain should be added or not??
		if( CluSeedPos.Perp() < 1810 && abs(CluSeedPos.Z()) < 2460 )
		{
			tmpChargedCore.push_back(a_clu);
		}
	}

	int NTrkHit = 0;
	TVector3 TrackEpPos;
	int DirectLinkFlag = 0;
	int TCFlag = 0;

	float DisMatrix_Track_Bush[NTrk][NClu];
	std::vector<Cluster*> TLCluster;
	std::vector<int> UnLinkedTracks;
	TLCluster.clear(); 
	UnLinkedTracks.clear();

	float candiclustersEn = 0;
	std::vector<float> TrkCluDis;   // To record the distance to Trk; used for sort; 
	std::vector<int> CluOrder;
	TrkCluDis.clear();

	CluOrder.clear();
	int Track_Core_ID = 0;
	float currTrkEn = 0; 

	cout<<" N Track"<<NTrk<<endl;
	for(int i1 = 0; i1 < NTrk; i1++)
	{
		Track * currTrk = SortedTracks[i1];
		NTrkHit = currTrk->getTrackerHits().size();
		TrackEpPos = (currTrk->getTrackerHits()[NTrkHit - 1])->getPosition();
		HelixClass * currHelix = new HelixClass();
		currHelix->Initialize_Canonical(currTrk->getPhi(), currTrk -> getD0(), currTrk -> getZ0(), currTrk -> getOmega(), currTrk->getTanLambda(), BField);
		TLCluster.clear();
		DirectLinkFlag = 0; TCFlag = 0;
		candiclustersEn = 0;
		TrkCluDis.clear();
		CluOrder.clear();
		currTrkEn = Track_Energy[currTrk];

		for(int i2 = 0; i2 < int( tmpChargedCore.size() ); i2++)
		{
			Cluster * a_clu = tmpChargedCore[i2];
			CluSeedPos = a_clu->getPosition();
			if( (CluSeedPos - TrackEpPos).Mag() < 0.1)
			{
				if( TouchFlag_EHBushes.find(a_clu) == TouchFlag_EHBushes.end() )
				{
					if(find(TLCluster.begin(), TLCluster.end(), a_clu) == TLCluster.end())
					{
						TLCluster.push_back(a_clu);
						TrkCluDis.push_back(0);
						DirectLinkFlag = 1;
						candiclustersEn = a_clu->getEnergy();
						break;
					}
				}
				else
				{
					cout<<"WARNING, EP been linked to other tracks already!!!!"<<endl;
					exit(4);
				}
			}
		}

		for(int i3 = 0; i3 < NClu; i3++)
		{
			Cluster* a_clu = SortedSMBushes[i3];
			float Dis = SimpleDisTrackClu(currTrk, a_clu);
			CluSeedPos = a_clu->getPosition();
			float CluDepth = DisSeedSurface(CluSeedPos);
			float TrkEpDis = (TrackEpPos - CluSeedPos).Mag();
			float ProjectiveTrackEpDis = TrkEpDis*(CluSeedPos - TrackEpPos).Angle(CluSeedPos);
			float CoreMergeDistanceDepthCorrector = 0;

			if(CluDepth > 20)
				CoreMergeDistanceDepthCorrector = 20;
			else if(CluDepth > 10)
				CoreMergeDistanceDepthCorrector = 10;

			//Shoulder condition: if CluSeedPosition At Ring Position, and Track Direction .
			// 1 + 0.5*(Track_Energy[currTrk] < 10.)*IsShoulder

			if(Dis > -0.1)
			{
				DisMatrix_Track_Bush[i1][i3] = Dis;

				if( Dis < 7 + CoreMergeDistanceDepthCorrector*(1 + 0.5*(currTrkEn < 10.)) && ( ProjectiveTrackEpDis < 100*(1 + 10.0/currTrkEn ) || currTrkEn < 3 )&& TouchFlag_EHBushes.find(a_clu) == TouchFlag_EHBushes.end() )
				{
					if( candiclustersEn < currTrkEn + sqrt( currTrkEn ) + 2.0 || (CluFD[a_clu] < 0.2 && a_clu->getCalorimeterHits().size() > 15) )
					{
						TrkCluDis.push_back(Dis);       // Or a function of Dis + Depth...
						TLCluster.push_back(a_clu);
						TCFlag = 1;
					}
					else
					{
						//cout<<"EH Bushes is too fat already, need to record EH component and split accordingly "<<candiclustersEn<<endl;
					}
				}
			}
			else
			{
				DisMatrix_Track_Bush[i1][i3] = 1.0E10;
			}
		}

		CluOrder = SortMeasure(TrkCluDis, 0);
		candiclustersEn = 0;
		std::vector<Cluster*> ChClusters;
		ChClusters.clear();

		ReconstructedParticleImpl * chargeparticle = new ReconstructedParticleImpl();
		chargeparticle->setEnergy( Track_Energy[currTrk] );
		float Charge = currTrk -> getOmega()/fabs(currTrk -> getOmega());
		chargeparticle->setCharge(Charge);
		chargeparticle->setMomentum( currHelix->getMomentum() );
		chargeparticle->addTrack( currTrk );
		delete currHelix;

		if(DirectLinkFlag || TCFlag)
		{

			for(unsigned int i4 = 0; i4 < TLCluster.size(); i4++)   //Will MergeIntoOne Cluster After absorbed all necessaries.
			{
				Cluster * tmpClu = TLCluster[CluOrder[i4]];
				if( candiclustersEn + tmpClu->getEnergy() < Track_Energy[currTrk] + sqrt( Track_Energy[currTrk] ) + 1.5 && TouchFlag_EHBushes.find(tmpClu) == TouchFlag_EHBushes.end() )
				{
					TouchFlag_EHBushes[tmpClu] = 2;
					ChClusters.push_back(tmpClu);
					candiclustersEn += tmpClu->getEnergy();
					chargeparticle->addCluster(tmpClu);
				}
			}

			ClusterImpl * chClu =  NaiveMergeClu(ChClusters);

			ChCluVec.push_back(chClu);

			NewClusterFlag(chClu, currTrk, col_TPCTrk);
			if(_outputtestroot)arborTree->Fill();
			Track_Core_ID = CluIDFlag;
			cout<<Track_Core_ID<<" "<<ClusterFlag(chClu, currTrk, col_TPCTrk)<<endl;
			//Track_Core_ID = ClusterFlag(chClu, currTrk, col_TPCTrk);
			if(Track_Core_ID == 130 || Track_Core_ID == 131)
				chargeparticle->setType( int(Charge*13) );
			else if(Track_Core_ID == 110 || Track_Core_ID == 111)
				chargeparticle->setType( int(Charge*11) );
			else if(Track_Core_ID == 211 || Track_Core_ID == 212)
				chargeparticle->setType( int(Charge*211) );
			else chargeparticle->setType(0);

			arborcore_ch->addElement(chargeparticle);
		}
		else
		{
			UnLinkedTracks.push_back(i1);
		}
	}

	std::vector<int> candiCluster_1st; 
	candiCluster_1st.clear(); 
	for(int j2 = 0; j2 < NClu; j2++)
	{
		Cluster * b_clu = SortedSMBushes[j2];
		if( TouchFlag_EHBushes.find(b_clu) == TouchFlag_EHBushes.end() )        //Should be some self-merge before.
		{
			candiCluster_1st.push_back(j2);
		}
	}

	// find closest, and reasonalby closed...; second iteration is needed to keep the excellent linking still valid 

	int UnLinkedTracks_2ndIteration = 0; 

	for(unsigned int i2 = 0; i2 < UnLinkedTracks.size(); i2++)
	{
		TLCluster.clear();
		Track* a_trk =  SortedTracks[ UnLinkedTracks[i2] ];
		float currTrkEn =  Track_Energy[a_trk];
		float ClosestDis = 1.0E12; 
		float currTrkCluDis = 1.0E12; 
		int ClosetIndex = -1; 
		float tmpClEn = 0; 

		for(unsigned int j2 = 0; j2 < candiCluster_1st.size(); j2++)	
		{
			currTrkCluDis = DisMatrix_Track_Bush[ UnLinkedTracks[i2] ][j2];
			if( ClosestDis > currTrkCluDis )
			{
				ClosestDis = currTrkCluDis ;
				ClosetIndex = j2; 
			}
			if( currTrkCluDis < (100.0/(currTrkEn + 1) + 5.0) && tmpClEn < currTrkEn + 2*sqrt(currTrkEn) + 2.0 )
			{
				TLCluster.push_back(SortedSMBushes[j2]);
				tmpClEn += SortedSMBushes[j2]->getEnergy();
			}
		}

		if(ClosetIndex > 0)
		{
			Cluster* ClosestClu = SortedSMBushes[ClosetIndex];
			if( find(TLCluster.begin(), TLCluster.end(), ClosestClu) == TLCluster.end() )
			{
				if(tmpClEn <  currTrkEn + 2*sqrt(currTrkEn) + 2.0 && ClosestDis < (100.0/(currTrkEn + 1) + 50.0) )
				{
					TLCluster.push_back(ClosestClu);
				}
			}
		}

		if( currTrkEn < 10.0 && ( Track_Type[a_trk]%10 == 1 || NTrkHit > 80 ) && (TLCluster.size() > 0 || currTrkEn < 3) )	// Energy Consrain can be released a little bit, add energy dependence. 
		{
			ReconstructedParticleImpl * chargeparticle = new ReconstructedParticleImpl();
			chargeparticle->setEnergy( currTrkEn );
			float Charge = a_trk -> getOmega()/fabs(a_trk -> getOmega());
			chargeparticle->setType( int(Charge*511) );		// Very Soft One...??
			chargeparticle->setCharge(Charge);
			chargeparticle->addTrack( a_trk );
			for(unsigned int i4 = 0; i4 < TLCluster.size(); i4++)    //Will MergeIntoOne Cluster After absorbed all necessaries.
			{
				TouchFlag_EHBushes[TLCluster[i4]] = 1;
				chargeparticle->addCluster(TLCluster[i4]);
			}
			arborcore_ch->addElement(chargeparticle);
		}
		else
		{
			UnLinkedTracks_2ndIteration++;
		}
	}

	//cout<<"UnLinkedTracks_2ndIteration "<<UnLinkedTracks_2ndIteration<<endl; 

	//Till Now, Energy Constrain Posed, but the Energy Satisfactory is not required. Absorbtion & Energy Flow senario need to be applied. 

	std::vector<Cluster*> LSCluster;
	std::vector<Cluster*> candiCluster_2nd;
	std::vector<Cluster*> candiNeCore;
	std::vector<Cluster*> candiNeFrag;
	LSCluster.clear();
	candiCluster_2nd.clear();
	candiNeCore.clear();
	candiNeFrag.clear();

	for(int n0 = 0; n0 < NClu; n0++)
	{
		Cluster * b_clu = SortedSMBushes[n0];
		if( TouchFlag_EHBushes.find(b_clu) == TouchFlag_EHBushes.end() )        //Should be some self-merge before.
		{
			candiCluster_2nd.push_back(b_clu);
			float CandiCluEn = b_clu->getEnergy();
			TVector3 CandiCluPos = b_clu->getPosition();
			float CandiCluDepth = DisSeedSurface(CandiCluPos);

			float ClosestDistanceToTrack = 1.0E10; 
			int ClosestTrkIndex = 0; 

			for( int t = 0; t < NTrk; t++ )
			{
				if( DisMatrix_Track_Bush[ t ][n0] < ClosestDistanceToTrack )
				{
					ClosestDistanceToTrack = DisMatrix_Track_Bush[ t ][n0];
					ClosestTrkIndex = t; 		//could be linked to trk_clu core pair and see if they are hungry
				}
			}			

			// ClosestDistanceToTrack * CandiCluEn > Sth = 100 * (2 - IsPhoton), first iteraton. Look into high Energy Tau Sample. 
			// Hard Neutral Core Condition: if Photon; 

			if( (CandiCluEn*(1 - 0.0006*CandiCluDepth) > 1 || (CandiCluDepth < 10 && CandiCluEn > 0.1)) && ClosestDistanceToTrack > 100 )// || CluID(b_clu) == 22 )	Maybe add some energy dependence. 
			{
				candiNeCore.push_back(b_clu);
			}
			else
			{
				candiNeFrag.push_back(b_clu);
			}
		}
	}

	std::vector<Cluster* > NeClu = ClusterAbsorbtion(candiNeCore, candiNeFrag, 50, 0.02);
	LCCollection *NeBush_2nd = ClusterVecColl(NeClu);
	evtPP->addCollection(NeBush_2nd, "NeBush_2ndIt");
	LCCollection *ChBush_2nd = ClusterVecColl(ChCluVec);
	evtPP->addCollection(ChBush_2nd, "ChBush_2ndIt");

	for(int j4 = 0; j4 < NeBush_2nd->getNumberOfElements(); j4++)
	{
		Cluster * b_clu = dynamic_cast<Cluster*>(NeBush_2nd->getElementAt(j4));
		if(b_clu->getCalorimeterHits().size() > 3)
		{
			ReconstructedParticleImpl * neutralparticle = new ReconstructedParticleImpl();
			neutralparticle->setEnergy( b_clu->getEnergy() );
			neutralparticle->setType(22);
			neutralparticle->setCharge(0);
			TVector3 Pos = b_clu->getPosition();
			Pos = b_clu->getEnergy()/Pos.Mag()*Pos;
			double currMom[3]={Pos.X(), Pos.Y(), Pos.Z()};
			neutralparticle->setMomentum( currMom );
			neutralparticle->addCluster(b_clu);
			arborcore_ch->addElement(neutralparticle);
		}
	}

	evtPP->addCollection(arborcore_ch, "ArborPFOs");

	//cout<<"Pothential ChargedCoreFinding "<<tmpChargedCore.size()<<endl;
}


void BushConnect::BushMCPMatch(LCEvent * evtPP)
{

	LCCollection *arborcore_ch = new LCCollectionVec(LCIO::RECONSTRUCTEDPARTICLE);  //Tight ones test
	LCCollection *arborcore_ne = new LCCollectionVec(LCIO::RECONSTRUCTEDPARTICLE);
	arborcore_ch->setFlag(Cluflag.getFlag());
	arborcore_ne->setFlag(Cluflag.getFlag());

	LCCollection * Clu = evtPP->getCollection("SMBush_2ndIt");
	int NClu = Clu->getNumberOfElements();

	LCCollection * MCP = evtPP->getCollection("MCParticle");
	int NMCP = MCP->getNumberOfElements();

	std::map<Cluster*, int> TouchFlagClu; 
	TouchFlagClu.clear();


	TVector3 VTX, EndP; 	
	std::vector<MCParticle*> chargedMCPs; 
	std::vector<float> MCPEn; 
	chargedMCPs.clear();
	MCPEn.clear();

	float TotalChPEn = 0;
	int NChP = 0;  
	for(int i = 0; i < NMCP; i++)	// Introduce some catelogies here, according to energy, incident angle, etc. Should separate barrel/endcap..., as in the track sorting algo
	{
		MCParticle * a_MCP = dynamic_cast<MCParticle*>(MCP->getElementAt(i));
		VTX = a_MCP->getVertex();
		EndP = a_MCP->getEndpoint();
		if( a_MCP->getCharge() != 0 && fabs( VTX.Z() ) < 8000 && VTX.Perp() < 3000 && (fabs(EndP.Z()) > 8000 || EndP.Perp() > 3000) )
		{
			chargedMCPs.push_back(a_MCP);
			NChP ++;
			TotalChPEn += a_MCP->getEnergy();
			MCPEn.push_back(a_MCP->getEnergy());
		}
	}

	std::vector<int> MCPIndex = SortMeasure(MCPEn, 1);
	//cout<<endl<<NChP<<" AAAAAAAA "<<TotalChPEn<<endl;
	std::map<Cluster*, TVector3> CluCenterPos;

	for(int p = 0; p < NClu; p++)	//already sorted
	{
		Cluster * a_Clu = dynamic_cast<Cluster*>(Clu->getElementAt(p));
		//cout<<p<<"th Clu has En: "<<a_Clu->getEnergy()<<endl; 
		CluCenterPos[a_Clu] = ClusterCoG(a_Clu);
	}

	std::map<std::pair<int, int>, float> TrkCluPair_Dis;
	std::map<std::pair<int, int>, float> CluPair_Dis; 
	TrkCluPair_Dis.clear();
	CluPair_Dis.clear();
	// std::vector<int > CHCoreClu;		//Should directly use these catelogies...
	// CHCoreClu.clear();
	std::vector<int > CHCoreClu_EB; 	//Energy Balanced Core_Trk Pair	
	CHCoreClu_EB.clear();
	std::vector<int > CHCoreClu_Hungry;     //Core Energy Significantly Smaller than Trk Momentum
	CHCoreClu_Hungry.clear();
	std::vector<int > CHCoreClu_OverFull;   //Core Energy Significantly Larger
	CHCoreClu_OverFull.clear();
	std::map<int, float> CoreClu_TrkEn;
	CoreClu_TrkEn.clear();

	int NMCP_in = chargedMCPs.size();
	TVector3 CoGPos, PosDiff, Mom;
	int ClosestCluID = -1; 
	float ClosestDis = 1.0E10; 
	float CurrMCPEn = 0;
	float CurrCoreCluEn = 0; 

	for(int i0 = 0; i0 < NMCP_in; i0++)	
	{
		MCParticle * a_MCP = chargedMCPs[MCPIndex[i0]];
		Mom = a_MCP->getMomentum();
		CurrMCPEn = Mom.Mag();
		ClosestDis = 1.0E10;
		ClosestCluID = -1;

		for(int j0 = 0; j0 < NClu; j0++)
		{
			Cluster * a_Clu = dynamic_cast<Cluster*>(Clu->getElementAt(j0));
			if(TouchFlagClu.find(a_Clu) == TouchFlagClu.end())
			{
				float currZ = CluCenterPos[a_Clu].Z();
				if(currZ * Mom.Z() > 0)
				{
					CoGPos = currZ/a_MCP->getMomentum()[2] * Mom;
					PosDiff = CoGPos - CluCenterPos[a_Clu];
					float currSep = PosDiff.Mag();
					if(currSep < 50)
					{
						std::pair<int, int> a_pair; 
						a_pair.first = MCPIndex[i0];
						a_pair.second = j0;
						TrkCluPair_Dis[a_pair] = currSep;
						if(currSep < ClosestDis)
						{
							ClosestDis = currSep; 
							ClosestCluID = j0;
						}
					}	
				}
			}
		}

		//cout<<ClosestCluID<<"\t"<<ClosestDis<<endl;

		if(ClosestCluID > -1 && ClosestDis < 50)	// or some function
		{
			//make core trk_clu pair
			ReconstructedParticleImpl * chargeparticle = new ReconstructedParticleImpl();
			chargeparticle->setEnergy( Mom.Mag() );
			chargeparticle->setCharge(a_MCP->getCharge());
			chargeparticle->setType(a_MCP->getPDG());
			chargeparticle->setMomentum( a_MCP->getMomentum() );
			Cluster * b_Clu = dynamic_cast<Cluster*>(Clu->getElementAt(ClosestCluID));
			TouchFlagClu[b_Clu] = 1;
			CurrCoreCluEn = b_Clu->getEnergy();
			chargeparticle->addCluster(b_Clu);
			CoreClu_TrkEn[ClosestCluID] = CurrMCPEn;

			if( fabs(CurrMCPEn - CurrCoreCluEn) <= 1.0*sqrt(CurrMCPEn) + 2 )	//Condition Dependent. Tend to use 3 sigma if guassian
			{
				CHCoreClu_EB.push_back(ClosestCluID);
			}
			else if( CurrCoreCluEn < CurrMCPEn - sqrt(CurrMCPEn) - 2.0 )
			{
				CHCoreClu_Hungry.push_back(ClosestCluID);
			}
			else
			{
				CHCoreClu_OverFull.push_back(ClosestCluID);
				//cout<<"WARNING: Cluster Energy Significantly Larger than Trk P "<<CurrCoreCluEn<<" >> "<<CurrMCPEn<<endl; 
			}

			arborcore_ch->addElement(chargeparticle);

			//cout<<"One Pair "<<CurrMCPEn<<" E/P "<<b_Clu->getEnergy()<<endl;
		}
	}

	// For neutral ones: distance to closest trk-cluster pair; if trk-cluster pair is energy balanced; 
	// Trk pair distance; clu-clu pair distance

	std::vector<int> UnTouched_1stIt_Clu; 	//Restrictions on the depth, Shape & energy, size should be added
	UnTouched_1stIt_Clu.clear();
	std::vector<int> NeutralCore_Clu;   //Restrictions on the depth, Shape & energy, size should be added
	NeutralCore_Clu.clear();
	TVector3 UnTouchedClu_Pos, tmpCorePos; 	
	float p_Depth = 0; 
	float p_Energy = 0; 
	int p_Size = 0; 
	float Core_UnTouched_Dis = 0;
	int EBSize = CHCoreClu_EB.size();
	int HungrySize = CHCoreClu_Hungry.size();
	int OverFullSize = CHCoreClu_OverFull.size();
	int currCoreType = -1;

	for(int j2 = 0; j2 < NClu; j2++)
	{
		Cluster * p_Clu = dynamic_cast<Cluster*>(Clu->getElementAt(j2));

		if(TouchFlagClu.find(p_Clu) == TouchFlagClu.end())
		{
			UnTouchedClu_Pos = p_Clu->getPosition();
			p_Depth = DisSeedSurface(UnTouchedClu_Pos);
			p_Energy = p_Clu->getEnergy();
			p_Size = p_Clu->getCalorimeterHits().size();
			// ID: if Photon
			if( p_Energy > 0.2 && ( (p_Size > 10 && p_Depth < 100) || p_Energy > 0.003*p_Depth ) )	// || Its obviously an low-E photon...	
			{
				UnTouched_1stIt_Clu.push_back(j2);
				//cout<<p_Depth<<" Depth Vs Energy "<<p_Energy<<"Loop Size "<<HungrySize + EBSize + OverFullSize<<endl; 

				for(int k2 = 0; k2 < HungrySize + EBSize + OverFullSize; k2++)
				{
					Cluster * a_Core; 
					int currCoreIndex = 0; 

					if( k2 < HungrySize )	//should be iteratively added back...
					{
						a_Core = dynamic_cast<Cluster*>(Clu->getElementAt(CHCoreClu_Hungry[k2]));
						currCoreType = 0;
						currCoreIndex = CHCoreClu_Hungry[k2];
					}
					else if( k2 < HungrySize + EBSize )
					{
						a_Core = dynamic_cast<Cluster*>(Clu->getElementAt(CHCoreClu_EB[k2 - HungrySize]));
						currCoreType = 1;
						currCoreIndex = CHCoreClu_EB[k2 - HungrySize];
					}
					else
					{
						a_Core = dynamic_cast<Cluster*>(Clu->getElementAt(CHCoreClu_OverFull[k2 - HungrySize - EBSize]));
						currCoreType = 2;
						currCoreIndex = CHCoreClu_OverFull[k2 - HungrySize - EBSize];
					}

					tmpCorePos = a_Core->getPosition();
					if( (tmpCorePos - UnTouchedClu_Pos).Mag() < 1500 )	// Protection, should be energy dependent
					{
						Core_UnTouched_Dis = BushDis( a_Core, p_Clu );		// Should have track extrapolation as well!!
						if( Core_UnTouched_Dis < 50 ) //&& currCoreType == 0 )
						{
							//cout<<"Should be absorbed!!! "<<Core_UnTouched_Dis<<endl; 
							std::pair<int, int> a_pair;
							a_pair.first = currCoreIndex;
							a_pair.second = j2;
							CluPair_Dis[a_pair] = Core_UnTouched_Dis;
							TouchFlagClu[p_Clu] = 2;
						}
					}
				}
			}
			else
			{
				TouchFlagClu[p_Clu] = 4; 	//Droped Frags
			}
		}
	}

	//cout<<"Linked and schemed;"<<endl; 

	for(int j1 = 0; j1 < NClu; j1++)
	{
		Cluster * c_Clu = dynamic_cast<Cluster*>(Clu->getElementAt(j1));

		if(TouchFlagClu.find(c_Clu) == TouchFlagClu.end())
		{
			TVector3 CluPos = c_Clu->getPosition();
			float cluMom[3] = {0, 0, 0};
			cluMom[0] = c_Clu->getEnergy()/CluPos.Mag()*c_Clu->getPosition()[0];
			cluMom[1] = c_Clu->getEnergy()/CluPos.Mag()*c_Clu->getPosition()[1];
			cluMom[2] = c_Clu->getEnergy()/CluPos.Mag()*c_Clu->getPosition()[2];
			ReconstructedParticleImpl * neutralparticle = new ReconstructedParticleImpl();
			neutralparticle->setEnergy(c_Clu->getEnergy());
			neutralparticle->addCluster(c_Clu);
			neutralparticle->setType(22);	//or 2212...
			neutralparticle->setMomentum(cluMom);
			arborcore_ne->addElement(neutralparticle);
		}
	}

	evtPP->addCollection(arborcore_ch, "ArborCharged");
	evtPP->addCollection(arborcore_ne, "ArborNeutral");

	//cout<<"NCount "<<NMCP_in<<" : "<<NClu<<" pair "<<TrkCluPair_Dis.size()<<endl; 
}

void BushConnect::ParticleReco(LCEvent * evtPP)
{

}

void BushConnect::processEvent( LCEvent * evtP )
{
	if (evtP)
	{
		eventNr = evtP->getEventNumber();

		if(eventNr%1 == 0)
			cout<<"Nevts Processed: "<<eventNr<<endl;

		BushConnect::Clean();	
		BushConnect::TrackSort( evtP ); 	
		BushConnect::BushSelfMerge( evtP );	// InterMerge EHBushes, without track information. Finaloutput is clusters with id.
		// BushConnect::BushMCPMatch(evtP);
		BushConnect::BushTrackMatch( evtP );	//  
		// BushConnect::ParticleReco( evtP );
	}
}

void BushConnect::end()
{
	std::cout<<"Bush Connection Finished, ArborObject Formed"<<std::endl;
	if (arborTree) {

		tree_file->Write();
		delete tree_file;
		delete arborTree;
	}


}

